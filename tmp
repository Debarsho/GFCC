Binary file build/parser matches
Binary file build/CMakeFiles/parser.dir/src/typo.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/consts.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/generated/lex.yy.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/generated/parser.tab.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/symtab.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/main.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/tree.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/ops.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/types2.cpp.o matches
Binary file build/CMakeFiles/parser.dir/src/ircodes.cpp.o matches
Binary file bin/parser matches
.git/hooks/fsmonitor-watchman.sample:	eval {
.git/hooks/fsmonitor-watchman.sample:		eval { launch_watchman() };
.git/hooks/pre-receive.sample:		eval "value=\$GIT_PUSH_OPTION_$i"
src/generated/parser.tab.cpp:   evaluated with infinite-precision integer arithmetic.  */
src/generated/parser.tab.cpp:			(yyval.node)->eval = (yyval.node)->label; // TODO
src/generated/parser.tab.cpp:			// cout << "\"" << $$->eval << "\"" << endl;
src/generated/parser.tab.cpp:				(yyval.node)->eval = (yyval.node)->label;
src/generated/parser.tab.cpp:				int *bound = eval(a1->dims[0]), *query = eval((yyvsp[-1].node));
src/generated/parser.tab.cpp:		if (!((yyval.node)->type->isErr)) (yyval.node)->eval = (yyvsp[-3].node)->eval + "[" + (yyvsp[-1].node)->eval + "]"; // handle at assembly code generation
src/generated/parser.tab.cpp:			cout << "\"" << (yyvsp[-2].node)->eval << "\"" << endl;
src/generated/parser.tab.cpp:			emit(eps, "call", (yyvsp[-2].node)->eval, "0"); // call <func / func_ptr>, 0
src/generated/parser.tab.cpp:			(yyval.node)->eval = newTmp();
src/generated/parser.tab.cpp:			emit((yyval.node)->eval, eps, "retval"); // call <func / func_ptr>, 0
src/generated/parser.tab.cpp:				node_t *ch = (yyvsp[-1].node)->ch(i); if (ch) emit(eps, "param", ch->eval); // param <ch->eval>
src/generated/parser.tab.cpp:			emit(eps, "call", (yyvsp[-3].node)->eval, to_string(l)); // call <func / func_ptr>, l
src/generated/parser.tab.cpp:			(yyval.node)->eval = newTmp();
src/generated/parser.tab.cpp:			emit((yyval.node)->eval, eps, "retval"); // call <func / func_ptr>, 0
src/generated/parser.tab.cpp:		(yyval.node)->eval = newTmp();
src/generated/parser.tab.cpp:		emit((yyval.node)->eval, eps, (yyvsp[-1].node)->eval);
src/generated/parser.tab.cpp:				emit((yyvsp[-1].node)->eval, "real+", (yyvsp[-1].node)->eval, "1");
src/generated/parser.tab.cpp:			else emit((yyvsp[-1].node)->eval, "+", (yyvsp[-1].node)->eval, "1");
src/generated/parser.tab.cpp:		else emit((yyvsp[-1].node)->eval, "+", (yyvsp[-1].node)->eval, "1");
src/generated/parser.tab.cpp:		(yyval.node)->eval = newTmp();
src/generated/parser.tab.cpp:		emit((yyval.node)->eval, eps, (yyvsp[-1].node)->eval);
src/generated/parser.tab.cpp:				emit((yyvsp[-1].node)->eval, "real-", (yyvsp[-1].node)->eval, "1");
src/generated/parser.tab.cpp:			else emit((yyvsp[-1].node)->eval, "-", (yyvsp[-1].node)->eval, "1");
src/generated/parser.tab.cpp:		else emit((yyvsp[-1].node)->eval, "-", (yyvsp[-1].node)->eval, "1");
src/generated/parser.tab.cpp:		(yyval.node)->eval = newTmp();
src/generated/parser.tab.cpp:				emit((yyvsp[0].node)->eval, "real+", (yyvsp[0].node)->eval, "1");
src/generated/parser.tab.cpp:			else emit((yyvsp[0].node)->eval, "+", (yyvsp[0].node)->eval, "1");
src/generated/parser.tab.cpp:		else emit((yyvsp[0].node)->eval, "+", (yyvsp[0].node)->eval, "1");
src/generated/parser.tab.cpp:		emit((yyval.node)->eval, eps, (yyvsp[0].node)->eval);
src/generated/parser.tab.cpp:		(yyval.node)->eval = newTmp();
src/generated/parser.tab.cpp:				emit((yyvsp[0].node)->eval, "real-", (yyvsp[0].node)->eval, "1");
src/generated/parser.tab.cpp:			else emit((yyvsp[0].node)->eval, "-", (yyvsp[0].node)->eval, "1");
src/generated/parser.tab.cpp:		else emit((yyvsp[0].node)->eval, "-", (yyvsp[0].node)->eval, "1");
src/generated/parser.tab.cpp:		emit((yyval.node)->eval, eps, (yyvsp[0].node)->eval);
src/generated/parser.tab.cpp:		string e1 = (yyvsp[-2].node)->eval, e2 = (yyvsp[0].node)->eval;
src/generated/parser.tab.cpp:				emit((yyvsp[-2].node)->eval, opr, e2);
src/generated/parser.tab.cpp:					if(isReal(t1)) emit((yyvsp[-2].node)->eval, "int2real", tmp, eps);
src/generated/parser.tab.cpp:					else emit((yyvsp[-2].node)->eval, "real2int", tmp, eps);
src/generated/parser.tab.cpp:				else emit((yyvsp[-2].node)->eval, opr, e1, e2);
src/generated/parser.tab.cpp:			(yyval.node)->eval = e1;
src/generated/parser.tab.cpp:		int *bound = eval((yyvsp[-1].node)); bool negErr = bound && (*bound < 0);
src/generated/parser.tab.cpp:		int *bound = eval((yyvsp[-1].node)); bool negErr = bound && (*bound < 0);
src/generated/parser.tab.cpp:		int *bound = eval((yyvsp[-1].node)); bool negErr = bound && (*bound < 0);
src/generated/parser.tab.cpp:		string tmp = (yyvsp[-1].node)->eval;
src/generated/parser.tab.cpp:		(yyval.node)->eval = newTmp();
src/generated/parser.tab.cpp:		emit((yyval.node)->eval,"==","---",tmp);
src/generated/parser.tab.cpp:		emit(eps, "ifgoto", "---", (yyval.node)->eval);
src/generated/parser.tab.cpp:		// $$->eval = tmp;
src/generated/parser.tab.cpp:		backpatch((yyvsp[0].node)->caselist,(yyvsp[-2].node)->eval);
src/generated/parser.tab.cpp:		emit(eps, "ifgoto", to_string(nextIdx()+2), (yyvsp[-1].node)->eval);
src/generated/parser.tab.cpp:			emit(eps, "ifgoto", to_string(nextIdx()+2), (yyvsp[-1].node)->eval);
src/generated/parser.tab.cpp:		emit(eps, "ifgoto", to_string((yyvsp[-7].nxtIstr)), (yyvsp[-2].node)->eval);
src/generated/parser.tab.cpp:		emit(eps, "ifgoto", "---", (yyvsp[0].node)->eval);
src/tree.cpp:	node->eval = "";
src/types.cpp:arrBnd::arrBnd(node_t* _evalNode) : evalNode(_evalNode) { } // normal declaration
src/types.cpp:unsigned int arrBnd::eval() { // TODO: evaluate the bound
src/types.cpp:	return (evalNode != NULL);
src/types.cpp:bool Type::newArrBnd(node_t* _evalNode) {
src/types.cpp:	arrBnd* ab = new arrBnd(_evalNode);
src/parser.y:			$$->eval = $$->label; // TODO
src/parser.y:			// cout << "\"" << $$->eval << "\"" << endl;
src/parser.y:				$$->eval = $$->label;
src/parser.y:				int *bound = eval(a1->dims[0]), *query = eval($3);
src/parser.y:		if (!($$->type->isErr)) $$->eval = $1->eval + "[" + $3->eval + "]"; // handle at assembly code generation
src/parser.y:			cout << "\"" << $1->eval << "\"" << endl;
src/parser.y:			emit(eps, "call", $1->eval, "0"); // call <func / func_ptr>, 0
src/parser.y:			$$->eval = newTmp();
src/parser.y:			emit($$->eval, eps, "retval"); // call <func / func_ptr>, 0
src/parser.y:				node_t *ch = $3->ch(i); if (ch) emit(eps, "param", ch->eval); // param <ch->eval>
src/parser.y:			emit(eps, "call", $1->eval, to_string(l)); // call <func / func_ptr>, l
src/parser.y:			$$->eval = newTmp();
src/parser.y:			emit($$->eval, eps, "retval"); // call <func / func_ptr>, 0
src/parser.y:		$$->eval = newTmp();
src/parser.y:		emit($$->eval, eps, $1->eval);
src/parser.y:				emit($1->eval, "real+", $1->eval, "1");
src/parser.y:			else emit($1->eval, "+", $1->eval, "1");
src/parser.y:		else emit($1->eval, "+", $1->eval, "1");
src/parser.y:		$$->eval = newTmp();
src/parser.y:		emit($$->eval, eps, $1->eval);
src/parser.y:				emit($1->eval, "real-", $1->eval, "1");
src/parser.y:			else emit($1->eval, "-", $1->eval, "1");
src/parser.y:		else emit($1->eval, "-", $1->eval, "1");
src/parser.y:		$$->eval = newTmp();
src/parser.y:				emit($2->eval, "real+", $2->eval, "1");
src/parser.y:			else emit($2->eval, "+", $2->eval, "1");
src/parser.y:		else emit($2->eval, "+", $2->eval, "1");
src/parser.y:		emit($$->eval, eps, $2->eval);
src/parser.y:		$$->eval = newTmp();
src/parser.y:				emit($2->eval, "real-", $2->eval, "1");
src/parser.y:			else emit($2->eval, "-", $2->eval, "1");
src/parser.y:		else emit($2->eval, "-", $2->eval, "1");
src/parser.y:		emit($$->eval, eps, $2->eval);
src/parser.y:		string e1 = $1->eval, e2 = $3->eval;
src/parser.y:				emit($1->eval, opr, e2);
src/parser.y:					if(isReal(t1)) emit($1->eval, "int2real", tmp, eps);
src/parser.y:					else emit($1->eval, "real2int", tmp, eps);
src/parser.y:				else emit($1->eval, opr, e1, e2);
src/parser.y:			$$->eval = e1;
src/parser.y:		int *bound = eval($3); bool negErr = bound && (*bound < 0);
src/parser.y:		int *bound = eval($2); bool negErr = bound && (*bound < 0);
src/parser.y:		int *bound = eval($3); bool negErr = bound && (*bound < 0);
src/parser.y:		string tmp = $2->eval;
src/parser.y:		$$->eval = newTmp();
src/parser.y:		emit($$->eval,"==","---",tmp);
src/parser.y:		emit(eps, "ifgoto", "---", $$->eval);
src/parser.y:		// $$->eval = tmp;
src/parser.y:		backpatch($5->caselist,$3->eval);
src/parser.y:		emit(eps, "ifgoto", to_string(nextIdx()+2), $3->eval);
src/parser.y:			emit(eps, "ifgoto", to_string(nextIdx()+2), $4->eval);
src/parser.y:		emit(eps, "ifgoto", to_string($2), $7->eval);
src/parser.y:		emit(eps, "ifgoto", "---", $1->eval);
src/include/types.h:	struct _node_t* evalNode = NULL; // NULL iff abstract declaration
src/include/types.h:		unsigned int eval(); // evaluate the bound
src/include/types2.h:    // unsigned int eval(int); // evaluate a bound
src/include/types2.h:int *eval(struct _node_t *); // evaluate bounds for arrays
src/include/gfcc_lexer.h:	std::string eval;
src/types2.cpp:Arr::Arr(class Type *_item, struct _node_t *_evalNode) : item(_item) { dims.push_back(_evalNode); }
src/types2.cpp:void Arr::newDim(struct _node_t *_evalNode) { dims.push_back(_evalNode); }
src/types2.cpp:int *eval(struct _node_t *n) { // evaluate bounds for arrays
src/ircodes.cpp:    string e1 = one->eval, e2 = three->eval;
src/ircodes.cpp:    dollar->eval = newTmp();
src/ircodes.cpp:    emit(dollar->eval, opr+op_label, e1, e2);
